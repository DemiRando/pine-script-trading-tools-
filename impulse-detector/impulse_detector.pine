//@version=6
indicator('Impulse Detector', overlay = true)

// Inputs
len_range = input.int(14, 'Avg Range Length', minval = 5)
k_mult = input.float(1.3, 'Impulse Distance Multiplier', step = 0.1)
max_bars = input.int(3, 'Max Bars for Impulse', minval = 1, maxval = 5)
overlap_th = input.float(0.35, 'Max Avg Body Overlap', step = 0.05)
sma_len = input.int(20, 'SMA Length')

avg_range = ta.sma(ta.tr(true), len_range)
sma = ta.sma(close, sma_len)

// Overlap normalized by smaller body to handle bull/bear symmetrically
body_overlap(a_open, a_close, b_open, b_close) =>
    a_high = math.max(a_open, a_close)
    a_low = math.min(a_open, a_close)
    b_high = math.max(b_open, b_close)
    b_low = math.min(b_open, b_close)

    overlap = math.max(0.0, math.min(a_high, b_high) - math.max(a_low, b_low))
    min_body = math.max(math.min(math.abs(a_close - a_open), math.abs(b_close - b_open)), syminfo.mintick)

    overlap / min_body

// Speed filter - price distance vs avg volatility
bull_dist = high - ta.lowest(low, max_bars)
bear_dist = ta.highest(high, max_bars) - low
bull_speed = bull_dist >= k_mult * avg_range
bear_speed = bear_dist >= k_mult * avg_range

// Noise filter - reject choppy overlapping candles
ov1 = body_overlap(open, close, open[1], close[1])
ov2 = body_overlap(open[1], close[1], open[2], close[2])
is_clean = (ov1 + ov2) / 2.0 <= overlap_th

// Structure confirmation
bull_structure = high > high[1] and high[1] > high[2]
bear_structure = low < low[1] and low[1] < low[2]

// Impulse = speed + clean movement + directional structure
bull_impulse = bull_speed and is_clean and bull_structure
bear_impulse = bear_speed and is_clean and bear_structure

// Visual
sma_color = bull_impulse ? color.lime : bear_impulse ? color.red : color.purple
plot(sma, color = sma_color, linewidth = 2)
