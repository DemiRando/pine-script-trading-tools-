//@version=6
indicator("Supply / Demand Zone Builder", overlay=true, max_boxes_count=200)

// Inputs
atr_len = input.int(14, "ATR Length", minval=1, group="Detection")
atr_mult = input.float(1.5, "ATR Multiplier", step=0.1, group="Detection",
  tooltip="Minimum price movement as multiple of ATR")
min_continuation = input.int(2, "Min Continuation Candles", minval=2, group="Detection")
require_atr = input.bool(true, "Require ATR Confirmation", group="Detection")

use_accuracy = input.bool(true, "Body-Based Zones", group="Zone Construction",
  tooltip="Use candle body instead of full range for tighter zones")
max_active = input.int(2, "Max Active Zones per Side", minval=1, group="Zone Management")
live_extend = input.bool(true, "Live Extend Zones", group="Zone Management",
  tooltip="Extends zones to current bar (may repaint)")

demand_color = input.color(color.new(color.green, 80), "Demand", group="Display")
supply_color = input.color(color.new(color.red, 80), "Supply", group="Display")

atr = ta.atr(atr_len)

// Reversal candidate state
var bool candidate_active = false
var int candidate_type = 0  // 1=demand, -1=supply
var float base_open = na
var float base_high = na
var float base_low = na
var float base_close = na
var float conf_high = na
var float conf_low = na
var int conf_count = 0
var int base_bar = na

// Zone storage (parallel arrays)
var box[] zones = array.new_box()
var int[] zone_type = array.new_int()
var bool[] zone_valid = array.new_bool()

// Helper: check if index is valid across all arrays
valid_idx(i) =>
    i >= 0 and i < array.size(zones) and i < array.size(zone_type) and i < array.size(zone_valid)

// Pause oldest active zone when limit reached
pause_oldest(ztype) =>
    int oldest = na
    int oldest_bar = bar_index * 2
    
    for i = 0 to array.size(zones) - 1
        if valid_idx(i) and array.get(zone_valid, i) and array.get(zone_type, i) == ztype
            left_bar = box.get_left(array.get(zones, i))
            if left_bar < oldest_bar
                oldest_bar := left_bar
                oldest := i
    
    if not na(oldest) and valid_idx(oldest)
        box.set_extend(array.get(zones, oldest), extend.none)
        array.set(zone_valid, oldest, false)

// Create new zone with limit enforcement
create_zone(top, bottom, is_demand) =>
    ztype = is_demand ? 1 : -1
    active = 0
    
    for i = 0 to array.size(zones) - 1
        if valid_idx(i) and array.get(zone_valid, i) and array.get(zone_type, i) == ztype
            active += 1
    
    if active >= max_active
        pause_oldest(ztype)
    
    zone_color = is_demand ? demand_color : supply_color
    b = box.new(base_bar, top, bar_index, bottom,
      xloc=xloc.bar_index, extend=extend.none,
      border_color=zone_color, bgcolor=zone_color)
    
    array.push(zones, b)
    array.push(zone_type, ztype)
    array.push(zone_valid, true)

// Detection: look for reversal setups
if barstate.isconfirmed
    is_bull = close > open
    is_bear = close < open
    was_bull = close[1] > open[1]
    was_bear = close[1] < open[1]
    
    if not candidate_active
        // Initiate demand candidate (bear → bull reversal)
        if was_bear and is_bull
            candidate_active := true
            candidate_type := 1
            base_open := open[1]
            base_high := high[1]
            base_low := low[1]
            base_close := close[1]
            conf_high := high
            conf_low := low
            conf_count := 1
            base_bar := bar_index - 1
        
        // Initiate supply candidate (bull → bear reversal)
        else if was_bull and is_bear
            candidate_active := true
            candidate_type := -1
            base_open := open[1]
            base_high := high[1]
            base_low := low[1]
            base_close := close[1]
            conf_high := high
            conf_low := low
            conf_count := 1
            base_bar := bar_index - 1
    
    else
        // Track demand confirmation
        if candidate_type == 1
            if is_bull
                conf_count += 1
                move = close - base_close
                confirmed = require_atr ? 
                  (conf_count >= min_continuation and move >= atr * atr_mult) :
                  (conf_count >= min_continuation)
                
                if confirmed
                    top = use_accuracy and base_high > conf_high ? base_open : base_high
                    bottom = math.min(base_low, conf_low)
                    create_zone(top, bottom, true)
                    candidate_active := false
            else
                candidate_active := false
        
        // Track supply confirmation
        else
            if is_bear
                conf_count += 1
                move = base_close - close
                confirmed = require_atr ?
                  (conf_count >= min_continuation and move >= atr * atr_mult) :
                  (conf_count >= min_continuation)
                
                if confirmed
                    top = math.max(base_high, conf_high)
                    bottom = use_accuracy and base_low < conf_low ? base_open : base_low
                    create_zone(top, bottom, false)
                    candidate_active := false
            else
                candidate_active := false

// Extend active zones to current bar
if array.size(zones) > 0 and (live_extend or barstate.isconfirmed)
    for ztype in array.from(1, -1)
        active_indices = array.new_int()
        
        for i = 0 to array.size(zones) - 1
            if valid_idx(i) and array.get(zone_valid, i) and array.get(zone_type, i) == ztype
                array.push(active_indices, i)
        
        // Only extend most recent max_active zones
        if array.size(active_indices) > 0
            start = math.max(array.size(active_indices) - max_active, 0)
            for j = start to array.size(active_indices) - 1
                idx = array.get(active_indices, j)
                if valid_idx(idx)
                    box.set_right(array.get(zones, idx), bar_index)

// Invalidate zones on wick break
if array.size(zones) > 0
    for i = 0 to array.size(zones) - 1
        if valid_idx(i) and array.get(zone_valid, i)
            z = array.get(zones, i)
            ztype = array.get(zone_type, i)
            top = box.get_top(z)
            bottom = box.get_bottom(z)
            
            // Demand zone broken below
            if ztype == 1 and low < bottom
                box.set_right(z, bar_index)
                box.set_extend(z, extend.none)
                array.set(zone_valid, i, false)
            
            // Supply zone broken above
            if ztype == -1 and high > top
                box.set_right(z, bar_index)
                box.set_extend(z, extend.none)
                array.set(zone_valid, i, false)
